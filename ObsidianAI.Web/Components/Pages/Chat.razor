@page "/"
@rendermode InteractiveServer
@using ObsidianAI.Web.Models
@using ObsidianAI.Web.Services
@using ObsidianAI.Web.Components.Shared
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.RegularExpressions
@inject IChatService ChatService
@inject NavigationManager NavigationManager
@inject IJSRuntime jsRuntime

<div class="header">
    <h1>üß† Obsidian AI</h1>
    <div class="header-actions">
        <button class="btn-icon" type="button" aria-label="Open Vault" @onclick="OpenVault">üìÅ Vault</button>
        <button class="btn-icon" type="button" aria-label="Open Settings" @onclick="OpenSettings">‚öôÔ∏è</button>
        <button class="btn-icon" type="button" aria-label="Show History" @onclick="ShowHistory">History</button>
    </div>
</div>

@if (isOpenRouter)
{
    <div class="privacy-warning" role="alert" aria-live="polite">
        <span class="privacy-warning-icon" aria-hidden="true">‚ö†Ô∏è</span>
        <div>
            <strong>Privacy Notice:</strong> You are using the OpenRouter LLM provider. Your prompts and data will be sent
            to a third-party cloud service.
        </div>
    </div>
}

<div class="chat-area">
    @if (conversationHistory.Any())
    {
        @foreach (var message in conversationHistory)
        {
            <MessageBubble Message="@message" OnActionConfirmed="HandleActionConfirmed"
                OnActionCancelled="HandleActionCancelled" OnActionEdit="HandleActionEdit" />
        }
    }
    else
    {
        <div class="welcome-message">
            <p>Welcome to Obsidian AI! How can I help you today?</p>
        </div>
    }
</div>

<div class="input-area">
    <div class="input-wrapper">
        <input type="text" class="input-field" placeholder="Type a message..." aria-label="Message input"
            @bind="currentMessage" @onkeypress="HandleKeyPress" disabled="@isProcessing" />
        <button class="btn-send" type="button" aria-label="Send message" @onclick="SendMessage"
            disabled="@isProcessing || string.IsNullOrWhiteSpace(currentMessage)">
            ‚Üí
        </button>
    </div>
    <div class="quick-actions" aria-label="Quick actions">
        <span class="quick-action-label">Quick actions:</span>
        @if (quickActions.Any())
        {
            @foreach (var action in quickActions)
            {
                <button class="quick-action-btn" type="button" @onclick="() => HandleQuickAction(action)">
                    @action.Label
                </button>
            }
        }
    </div>
</div>

@code {
    private HubConnection? hubConnection;
    private List<ChatMessage> conversationHistory = new();
    private List<QuickAction> quickActions = new();
    private string currentMessage = string.Empty;
    private bool isProcessing = false;
    private ChatMessage? currentAiMessage;
    private string llmProvider = string.Empty;
    private bool isOpenRouter = false;

    protected override async Task OnInitializedAsync()
    {
        await FetchLlmProvider();
        await InitializeSignalR();
        await LoadQuickActions();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ScrollToBottom();
        }
    }

    private async Task InitializeSignalR()
    {
        hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/chathub"))
        .WithAutomaticReconnect()
        .Build();

        hubConnection.On<string>("ReceiveToken", (token) =>
        {
            InvokeAsync(() =>
    {
            if (currentAiMessage != null)
            {
            // Find the message in the list
                var index = conversationHistory.FindLastIndex(m => m.Id == currentAiMessage.Id);
                if (index >= 0)
                {
                // Create updated message (remove processing indicator on first token)
                    currentAiMessage = currentAiMessage with
                    {
                        Content = currentAiMessage.Content + token,
                        IsProcessing = false // <-- Add this line
                    };
                // Replace in list
                    conversationHistory[index] = currentAiMessage;
                    try
                    {
                        StateHasChanged();
                    }
                    catch (InvalidOperationException)
                    {
                    // Component may have been disposed, ignore
                    }
                }
            }
        });
        });

        hubConnection.On<string>("MessageComplete", (finalMessage) =>
        {
            InvokeAsync(async () =>
    {
            if (currentAiMessage != null)
            {
            // Parse the message for action cards or search results
                await ParseResponseForComponents(finalMessage);

                currentAiMessage = currentAiMessage with { IsProcessing = false };
                currentAiMessage = null;
                isProcessing = false;
                try
                {
                    StateHasChanged();
                }
                catch (InvalidOperationException)
                {
                // Component may have been disposed, ignore
                }
                await ScrollToBottom();
            }
        });
        });

        hubConnection.On<string>("Error", (error) =>
        {
            InvokeAsync(() =>
    {
            if (currentAiMessage != null)
            {
                currentAiMessage = new ChatMessage
                {
                    Content = $"Error: {error}",
                    Sender = MessageSender.AI,
                    Timestamp = DateTime.UtcNow
                };
                currentAiMessage = null;
                isProcessing = false;
                try
                {
                    StateHasChanged();
                }
                catch (InvalidOperationException)
                {
                // Component may have been disposed, ignore
                }
            }
        });
        });

        await hubConnection.StartAsync();
    }

    private async Task LoadQuickActions()
    {
        quickActions = await ChatService.GetQuickActionsAsync();
    }

    private async Task FetchLlmProvider()
    {
        var provider = await ChatService.GetLlmProviderAsync();
        llmProvider = provider;
        isOpenRouter = string.Equals(provider, "OpenRouter", StringComparison.OrdinalIgnoreCase);
        StateHasChanged();
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isProcessing)
            return;

        var userMessage = new ChatMessage
        {
            Content = currentMessage,
            Sender = MessageSender.User,
            Timestamp = DateTime.UtcNow
        };

        conversationHistory.Add(userMessage);
        var messageToSend = currentMessage;
        currentMessage = string.Empty;
        isProcessing = true;

        // Create a placeholder AI message for streaming
        currentAiMessage = new ChatMessage
        {
            Content = string.Empty,
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow,
            IsProcessing = true,
            ProcessingType = ProcessingType.Thinking
        };

        conversationHistory.Add(currentAiMessage);
        StateHasChanged();
        await ScrollToBottom();

        try
        {
            var responseMessage = await ChatService.SendMessageAndGetResponseAsync(messageToSend);

            // Remove the processing placeholder
            conversationHistory.Remove(currentAiMessage!);

            // Set current AI message and add to history BEFORE parsing so it can be updated in place
            currentAiMessage = responseMessage with
            {
                IsProcessing = false,
                ProcessingType = ProcessingType.None
            };
            conversationHistory.Add(currentAiMessage);

            // Parse for ActionCard/FileOperation and update the message in-place
            await ParseResponseForComponents(responseMessage.Content);

            isProcessing = false;
            currentAiMessage = null;
            StateHasChanged();
            await ScrollToBottom();
        }
        catch (Exception ex)
        {
            // Handle connection errors
            if (currentAiMessage != null)
            {
                var errorMessage = new ChatMessage
                {
                    Content = $"Connection error: {ex.Message}",
                    Sender = MessageSender.AI,
                    Timestamp = DateTime.UtcNow
                };

                conversationHistory.Remove(currentAiMessage);
                conversationHistory.Add(errorMessage);
                currentAiMessage = null;
                isProcessing = false;
            }
            StateHasChanged();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private Task HandleQuickAction(QuickAction action)
    {
        currentMessage = action.Prefix;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task HandleActionConfirmed(string actionId)
    {
        // Find the message with this action card
        var message = conversationHistory.FirstOrDefault(m => m.ActionCard?.Id == actionId);
        if (message != null && message.ActionCard != null)
        {
            // Update the action card status
            message = message with
            {
                ActionCard = message.ActionCard with
                {
                    Status = ActionCardStatus.Processing
                }
            };

            // Update in the list
            var index = conversationHistory.IndexOf(conversationHistory.First(m => m.ActionCard?.Id == actionId));
            conversationHistory[index] = message;

            StateHasChanged();

            // Execute the action via the chat service
            try
            {
                var request = new ReorganizeRequest
                {
                    Operation = message.ActionCard.OperationType.ToString(),
                    FileOperations = message.ActionCard.Actions.Select(a => new FileOperation
                    {
                        SourcePath = a.Source,
                        DestinationPath = a.Destination,
                        Operation = a.Type.ToString()
                    }).ToList(),
                    ConfirmationId = actionId
                };

                var response = await ChatService.ReorganizeAsync(request);

                // Update the action card with the result
                message = message with
                {
                    ActionCard = message.ActionCard with
                    {
                        Status = response.Success ? ActionCardStatus.Completed : ActionCardStatus.Failed,
                        StatusMessage = response.Message
                    }
                };

                conversationHistory[index] = message;
            }
            catch (Exception ex)
            {
                message = message with
                {
                    ActionCard = message.ActionCard! with
                    {
                        Status = ActionCardStatus.Failed,
                        StatusMessage = $"Failed to execute actions: {ex.Message}"
                    }
                };

                conversationHistory[index] = message;
            }

            StateHasChanged();
        }
    }

    private Task HandleActionCancelled(string actionId)
    {
        // Find the message with this action card
        var message = conversationHistory.FirstOrDefault(m => m.ActionCard?.Id == actionId);
        if (message != null && message.ActionCard != null)
        {
            // Update the action card status
            message = message with
            {
                ActionCard = message.ActionCard with
                {
                    Status = ActionCardStatus.Cancelled,
                    StatusMessage = "Action cancelled by user"
                }
            };

            // Update in the list
            var index = conversationHistory.IndexOf(conversationHistory.First(m => m.ActionCard?.Id == actionId));
            conversationHistory[index] = message;

            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    private async Task HandleActionEdit(string actionId)
    {
        // For now, just show a message
        // In a real implementation, this would open an edit dialog
        var editMessage = new ChatMessage
        {
            Content = "Edit functionality not yet implemented. Please cancel and retry with a different request.",
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow
        };

        conversationHistory.Add(editMessage);
        StateHasChanged();
        await ScrollToBottom();
    }

private Task ParseResponseForComponents(string response)
{
    // Check if this is a confirmation request (agent asking permission)
    if (ContainsConfirmationKeywords(response))
    {
        // Pattern 1: "Append to file: X with content: Y"
        var fileOpPattern1 = new Regex(
            @"(?i)(append|create|write|modify|patch|delete)\s+to\s+file:\s*[`""']?([^`""'\n]+\.md)[`""']?\s+with\s+content:\s*[""']([^""'\n]+)[""']",
            RegexOptions.IgnoreCase);
        var fileOpMatch = fileOpPattern1.Match(response);

        // Pattern 2: "append [content] to [file]"
        if (!fileOpMatch.Success)
        {
            var fileOpPattern2 = new Regex(
                @"(?i)(append|create|write|modify|patch|delete)\s+(?:the\s+)?(?:content:?\s*)?[""']([^""'\n]+?)[""']?\s+(?:to|in)\s+(?:the\s+)?(?:file:?\s*)?[`""']?([^`""'\n.]+\.md)",
                RegexOptions.IgnoreCase);
            fileOpMatch = fileOpPattern2.Match(response);
        }

        if (fileOpMatch.Success)
        {
            var operation = fileOpMatch.Groups[1].Value.Trim();
            string content;
            string filePath;

            // Check which pattern matched and extract accordingly
            if (response.Contains("with content:"))
            {
                filePath = fileOpMatch.Groups[2].Value.Trim();
                content = fileOpMatch.Groups[3].Value.Trim();
            }
            else
            {
                content = fileOpMatch.Groups[2].Value.Trim();
                filePath = fileOpMatch.Groups[3].Value.Trim();
            }

            // Create ActionCard for confirmation
            var actionCard = new ActionCardData
            {
                Id = Guid.NewGuid().ToString(),
                Title = $"{char.ToUpper(operation[0])}{operation.Substring(1).ToLower()} Content",
                OperationType = operation.ToLowerInvariant() switch
                {
                    "append" => ActionOperationType.Other,
                    "create" => ActionOperationType.Create,
                    "delete" => ActionOperationType.Delete,
                    _ => ActionOperationType.Other
                },
                Actions = new List<PlannedAction>
                {
                    new PlannedAction
                    {
                        Type = operation.ToLowerInvariant() switch
                        {
                            "append" => ActionType.Modify,
                            "create" => ActionType.Create,
                            "delete" => ActionType.Delete,
                            "modify" => ActionType.Modify,
                            "patch" => ActionType.Modify,
                            "write" => ActionType.Modify,
                            _ => ActionType.Other
                        },
                        Source = filePath,
                        Destination = filePath,
                        Description = $"{char.ToUpper(operation[0])}{operation.Substring(1).ToLower()} \"{content}\" ‚Üí {filePath}"
                    }
                },
                Status = ActionCardStatus.Pending
            };

            // Attach to the current AI message in history
            int index = -1;
            if (currentAiMessage != null)
            {
                index = conversationHistory.FindLastIndex(m => m.Id == currentAiMessage.Id);
            }
            if (index < 0)
            {
                index = conversationHistory.FindLastIndex(m => m.Sender == MessageSender.AI);
            }

            if (index >= 0)
            {
                var msg = conversationHistory[index];
                var updated = msg with
                {
                    ActionCard = actionCard,
                    ProcessingType = ProcessingType.None
                };
                conversationHistory[index] = updated;

                if (currentAiMessage != null && currentAiMessage.Id == msg.Id)
                {
                    currentAiMessage = updated;
                }
            }

            return Task.CompletedTask;
        }
    }

    // If not a confirmation request, check if it's a completed operation
    var completedOpMatch = Regex.Match(response,
        @"(?i)(created|appended|modified|patched|wrote)\s+(?:to\s+)?(?:file:?\s*)?[`""']?([^`""'\n]+\.md)",
        RegexOptions.IgnoreCase);

    if (completedOpMatch.Success)
    {
        var action = completedOpMatch.Groups[1].Value.Trim();
        var filePath = completedOpMatch.Groups[2].Value.Trim();

        var fileOperationData = new FileOperationData
        {
            Action = char.ToUpper(action[0]) + action.Substring(1),
            FilePath = filePath
        };

        int index = -1;
        if (currentAiMessage != null)
        {
            index = conversationHistory.FindLastIndex(m => m.Id == currentAiMessage.Id);
        }
        if (index < 0)
        {
            index = conversationHistory.FindLastIndex(m => m.Sender == MessageSender.AI);
        }

        if (index >= 0)
        {
            var msg = conversationHistory[index];
            var updated = msg with
            {
                FileOperation = fileOperationData,
                ProcessingType = ProcessingType.None
            };
            conversationHistory[index] = updated;

            if (currentAiMessage != null && currentAiMessage.Id == msg.Id)
            {
                currentAiMessage = updated;
            }
        }
    }

    return Task.CompletedTask;
}

    private static bool ContainsConfirmationKeywords(string text)
    {
        var lower = text.ToLowerInvariant();
        return lower.Contains("confirm") ||
        lower.Contains("confirmation") ||
        lower.Contains("proceed") ||
        lower.Contains("are you sure") ||
        lower.Contains("please verify") ||
        lower.Contains("i will perform") ||
        lower.Contains("planned operations");
    }

    private static ActionOperationType DetermineOperationType(List<PlannedAction> actions)
    {
        if (actions.All(a => a.Type == ActionType.Move))
            return ActionOperationType.Move;
        if (actions.All(a => a.Type == ActionType.Delete))
            return ActionOperationType.Delete;
        if (actions.All(a => a.Type == ActionType.Create))
            return ActionOperationType.Create;
        if (actions.Count > 3)
            return ActionOperationType.Reorganize;
        return ActionOperationType.Other;
    }

    private static bool ExtractPaths(string text, out List<string> paths)
    {
        paths = ExtractAllPaths(text);
        return paths.Count >= 2;
    }

    private static List<string> ExtractAllPaths(string text)
    {
        var results = new HashSet<string>();

        // Pattern 1: Quoted paths
        var quotedMatches = System.Text.RegularExpressions.Regex.Matches(text, @"""([^""]+\.[a-zA-Z0-9]+)""");
        foreach (System.Text.RegularExpressions.Match m in quotedMatches)
        {
            results.Add(m.Groups[1].Value);
        }

        // Pattern 2: Backtick paths
        var backtickMatches = System.Text.RegularExpressions.Regex.Matches(text, @"`([^`]+\.[a-zA-Z0-9]+)`");
        foreach (System.Text.RegularExpressions.Match m in backtickMatches)
        {
            results.Add(m.Groups[1].Value);
        }

        // Pattern 3: Paths with slashes and extensions
        var slashMatches = System.Text.RegularExpressions.Regex.Matches(text, @"([\w\-./\\]+\.[a-zA-Z0-9]+)");
        foreach (System.Text.RegularExpressions.Match m in slashMatches)
        {
            var path = m.Groups[1].Value.Trim();
            if (!path.StartsWith("http") && !path.StartsWith("www"))
            {
                results.Add(path);
            }
        }

        return results.ToList();
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(100); // Small delay to ensure DOM is updated
        await jsRuntime.InvokeVoidAsync("scrollToBottom");
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private void OpenVault()
    {
        var vaultMessage = new ChatMessage
        {
            Content = "Vault feature is coming soon!",
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow
        };
        conversationHistory.Add(vaultMessage);
        StateHasChanged();
    }

    private void OpenSettings()
    {
        var settingsMessage = new ChatMessage
        {
            Content = "Settings feature is coming soon!",
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow
        };
        conversationHistory.Add(settingsMessage);
        StateHasChanged();
    }

    private void ShowHistory()
    {
        var historyMessage = new ChatMessage
        {
            Content = "History feature is coming soon!",
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow
        };
        conversationHistory.Add(historyMessage);
        StateHasChanged();
    }
}