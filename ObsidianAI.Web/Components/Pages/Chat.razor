@page "/"
@rendermode InteractiveServer
@implements IAsyncDisposable
@using ObsidianAI.Web.Models
@using ObsidianAI.Web.Services
@using ObsidianAI.Web.Components.Shared
@using Microsoft.AspNetCore.SignalR.Client
@using System.Collections.Generic
@using System.Text.RegularExpressions
@using System.Text.Json
@using Microsoft.Extensions.Logging
@using Microsoft.AspNetCore.WebUtilities
@using System.IO
@using System.Linq
@inject IChatService ChatService
@inject IVaultService VaultService
@inject NavigationManager NavigationManager
@inject IJSRuntime jsRuntime
@inject ILogger<Chat> Logger
@inject IConfiguration Configuration
@inject HttpClient HttpClient

<ChatHeader Conversation="currentConversationMetadata"
            IsExportEnabled="@currentConversationId.HasValue"
            OnTitleChanged="HandleConversationTitleChangedAsync"
            OnExport="HandleExportConversationAsync"
            OnVaultClick="OpenVault"
            OnSettingsClick="OpenSettings"
            OnHistoryClick="ShowHistory"
            CurrentProvider="@llmProvider" />

<PrivacyWarning IsVisible="@(isOpenRouter && !isPrivacyWarningDismissed)" 
                OnDismiss="DismissPrivacyWarning" />

@if (isSidebarOpen)
{
    <ConversationSidebar
        Conversations="conversationSummaries"
        SelectedConversationId="currentConversationId"
        IsLoading="isLoadingConversations"
        OnConversationSelected="HandleConversationSelectedAsync"
        OnClose="CloseSidebar"
        OnNewConversation="HandleNewConversationAsync"
        OnDeleteConversation="HandleDeleteConversationAsync"
        OnArchiveConversation="HandleArchiveConversationAsync" />
}

@if (isVaultBrowserOpen)
{
    <VaultBrowser IsOpen="isVaultBrowserOpen"
                  OnClose="CloseVaultBrowser"
                  OnFileSelected="HandleFileSelected" />
}

<ChatArea Messages="@conversationHistory"
          OnActionConfirmed="HandleActionConfirmed"
          OnActionCancelled="HandleActionCancelled"
          OnActionEdit="HandleActionEdit" />

<AttachmentUploader @ref="attachmentUploader" ConversationId="currentConversationId" OnAttachmentUploaded="HandleAttachmentUploaded" />

<ChatInput MessageText="@currentMessage"
           MessageTextChanged="OnMessageTextChanged"
           IsProcessing="@isProcessing"
           QuickActions="@quickActions"
           OnSendMessage="SendMessage"
           OnQuickAction="HandleQuickActionCallback"
           OnAttachmentClick="HandleAttachmentClick" />

@code {
    private HubConnection? hubConnection;
    private List<ChatMessage> conversationHistory = new();
    private List<QuickAction> quickActions = new();
    private string currentMessage = string.Empty;
    private bool isProcessing = false;
    private bool isStreaming = false;
    private ChatMessage? currentAiMessage;
    private string llmProvider = string.Empty;
    private bool isOpenRouter = false;
    private bool isPrivacyWarningDismissed = false;
    private int tokenBatchCount = 0;
    private const int TokenBatchSize = 3;
    private Guid? currentConversationId;
    private ConversationMetadata? currentConversationMetadata;
    private List<ConversationSummary> conversationSummaries = new();
    private bool isSidebarOpen;
    private bool isLoadingConversations;
    private bool isVaultBrowserOpen;
    private string? pendingUserMessageClientId;
    private string? pendingAssistantMessageClientId;
    private AttachmentUploader? attachmentUploader;
    private static readonly Regex FileOpPattern1 = new(
        @"(?i)(append|create|write|modify|patch|delete)\s+to\s+file:\s*[`""']?([^`""'\n]+\.md)[`""']?\s+with\s+content:\s*[""']([^""'\n]+)[""']",
        RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.NonBacktracking,
        TimeSpan.FromMilliseconds(100));
    private static readonly Regex FileOpPattern2 = new(
        @"(?i)(append|create|write|modify|patch|delete)\s+(?:the\s+)?(?:content:?\s*)?[""']([^""'\n]+?)[""']?\s+(?:to|in)\s+(?:the\s+)?(?:file:?\s*)?[`""']?([^`""'\n.]+\.md)",
        RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.NonBacktracking,
        TimeSpan.FromMilliseconds(100));
    private static readonly Regex CompletedOpPattern = new(
        @"(?i)(created|appended|modified|patched|wrote)\s+(?:to\s+)?(?:file:?\s*)?[`""']?([^`""'\n]+\.md)",
        RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.NonBacktracking,
        TimeSpan.FromMilliseconds(100));

    private static readonly Regex MicrosoftLearnUrlPattern = new(
        @"https?://[^\s]+",
        RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.NonBacktracking,
        TimeSpan.FromMilliseconds(100));

    private static readonly string[] MicrosoftLearnHosts = new[]
    {
        "learn.microsoft.com",
        "review.learn.microsoft.com",
        "aka.ms"
    };

    protected override async Task OnInitializedAsync()
    {
        await FetchLlmProvider();
        await InitializeSignalR();
        await LoadQuickActions();
        await RefreshConversationListAsync();
        await TryLoadConversationFromQueryAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ScrollToBottom();
        }
    }

    private async Task InitializeSignalR()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/chathub"))
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<string>("ReceiveToken", (token) =>
        {
            InvokeAsync(() =>
            {
                if (currentAiMessage != null)
                {
                    // Find the message in the list
                    var index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
                    if (index >= 0)
                    {
                        // Create updated message (remove processing indicator on first token)
                        currentAiMessage = currentAiMessage with
                        {
                            Content = currentAiMessage.Content + token,
                            IsProcessing = false
                        };
                        
                        // Replace in list
                        conversationHistory[index] = currentAiMessage;
                        
                        // Implement token batching: only update UI every N tokens
                        tokenBatchCount++;
                        if (tokenBatchCount >= TokenBatchSize)
                        {
                            tokenBatchCount = 0;
                            try
                            {
                                StateHasChanged();
                            }
                            catch (InvalidOperationException)
                            {
                                // Component may have been disposed, ignore
                            }
                        }
                    }
                }
            });
        });

        hubConnection.On<string>("Metadata", metadataJson =>
        {
            _ = HandleMetadataAsync(metadataJson);
        });

        hubConnection.On<string>("ActionCard", actionCardJson =>
        {
            _ = HandleServerActionCardAsync(actionCardJson);
        });

        hubConnection.On<object>("StatusUpdate", (update) =>
        {
            InvokeAsync(() =>
            {
                if (currentAiMessage != null)
                {
                    try
                    {
                        // Extract tool name from update object
                        var json = System.Text.Json.JsonSerializer.Serialize(update);
                        var statusObj = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(json);
                        
                        if (statusObj.TryGetProperty("tool", out var toolProp))
                        {
                            var toolName = toolProp.GetString();
                            
                            // Update the AI message with tool call status
                            var index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
                            if (index >= 0)
                            {
                                var content = currentAiMessage.Content + $"\n\nüîç Calling {toolName}...\n\n";
                                var tools = currentAiMessage.ToolsUsed ?? new List<string>();

                                if (!string.IsNullOrWhiteSpace(toolName) && !tools.Any(t => string.Equals(t, toolName, StringComparison.OrdinalIgnoreCase)))
                                {
                                    tools = new List<string>(tools) { toolName! };
                                }

                                currentAiMessage = currentAiMessage with
                                {
                                    Content = content,
                                    ToolsUsed = tools
                                };
                                conversationHistory[index] = currentAiMessage;
                                StateHasChanged();
                            }
                        }
                    }
                    catch (Exception)
                    {
                        // Ignore errors parsing status update
                    }
                }
            });
        });

        hubConnection.On<string>("MessageComplete", (finalMessage) =>
        {
            InvokeAsync(async () =>
            {
                if (currentAiMessage != null)
                {
                    // Ensure any remaining tokens are displayed
                    tokenBatchCount = 0;
                    
                    // Parse the message for action cards or search results
                    await ParseResponseForComponents(finalMessage);

                    var index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
                    if (index >= 0)
                    {
                        var completedMessage = conversationHistory[index];
                        completedMessage = AttachMicrosoftLearnSources(completedMessage, finalMessage, Logger);
                        completedMessage = completedMessage with { IsProcessing = false };
                        conversationHistory[index] = completedMessage;
                    }
                    
                    currentAiMessage = null;
                    isProcessing = false;
                    isStreaming = false;
                    
                    try
                    {
                        StateHasChanged();
                    }
                    catch (InvalidOperationException)
                    {
                        // Component may have been disposed, ignore
                    }
                    await ScrollToBottom();
                }
            });
        });

        hubConnection.On<string>("Error", (error) =>
        {
            InvokeAsync(() =>
            {
                if (currentAiMessage != null)
                {
                    var index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
                    if (index >= 0)
                    {
                        currentAiMessage = currentAiMessage with
                        {
                            Content = currentAiMessage.Content + $"\n\nError: {error}",
                            IsProcessing = false
                        };
                        conversationHistory[index] = currentAiMessage;
                    }
                    
                    currentAiMessage = null;
                    isProcessing = false;
                    isStreaming = false;
                    
                    try
                    {
                        StateHasChanged();
                    }
                    catch (InvalidOperationException)
                    {
                        // Component may have been disposed, ignore
                    }
                }
            });
        });

        await hubConnection.StartAsync();
    }

    private async Task LoadQuickActions()
    {
        var actions = await ChatService.GetQuickActionsAsync();
        quickActions = actions.ToList();
    }

    private async Task FetchLlmProvider()
    {
        var provider = await ChatService.GetLlmProviderAsync();
        llmProvider = provider;
        isOpenRouter = string.Equals(provider, "OpenRouter", StringComparison.OrdinalIgnoreCase);
        StateHasChanged();
    }

    private async Task EnsureConversationInitializedAsync()
    {
        if (currentConversationId.HasValue)
        {
            return;
        }

        try
        {
            var conversationId = await ChatService.CreateConversationAsync();
            pendingAssistantMessageClientId = null;
            pendingUserMessageClientId = null;
            AddOptimisticConversationSummary(conversationId);
            await LoadConversationAsync(conversationId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize conversation");
            throw;
        }
    }

    private async Task RefreshConversationListAsync()
    {
        try
        {
            isLoadingConversations = true;
            var summaries = await ChatService.ListConversationsAsync();
            conversationSummaries = summaries?.ToList() ?? new List<ConversationSummary>();

            if (currentConversationId.HasValue && currentConversationMetadata != null)
            {
                var summary = conversationSummaries.FirstOrDefault(c => c.Id == currentConversationId.Value);
                if (summary != null)
                {
                    currentConversationMetadata = currentConversationMetadata with
                    {
                        Title = summary.Title,
                        UpdatedAt = summary.UpdatedAt,
                        MessageCount = summary.MessageCount,
                        Provider = summary.Provider,
                        ModelName = summary.ModelName
                    };
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load conversation summaries");
        }
        finally
        {
            isLoadingConversations = false;
            StateHasChanged();
        }
    }

    private async Task TryLoadConversationFromQueryAsync()
    {
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        if (string.IsNullOrEmpty(uri.Query))
        {
            return;
        }

        var query = QueryHelpers.ParseQuery(uri.Query);
        if (query.TryGetValue("conversationId", out var conversationValues) &&
            Guid.TryParse(conversationValues.FirstOrDefault(), out var conversationId))
        {
            Logger.LogInformation("Loading conversation from URL query: {ConversationId}", conversationId);
            try
            {
                await LoadConversationAsync(conversationId);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load conversation from URL query, clearing query param: {ConversationId}", conversationId);
                ClearConversationRoute();
            }
        }
    }

    private async Task LoadConversationAsync(Guid conversationId)
    {
        Logger.LogInformation("Starting to load conversation {ConversationId}", conversationId);
        try
        {
            var detail = await ChatService.LoadConversationAsync(conversationId);
            Logger.LogInformation("Successfully loaded conversation {ConversationId} with {MessageCount} messages", conversationId, detail.Messages.Count);
            currentConversationId = detail.Id;
            conversationHistory = detail.Messages.ToList();
            currentConversationMetadata = new ConversationMetadata(
                detail.Id,
                detail.Title,
                detail.CreatedAt,
                detail.UpdatedAt,
                detail.IsArchived,
                detail.Provider,
                detail.ModelName,
                detail.Messages.Count);

            var summary = new ConversationSummary(
                detail.Id,
                detail.Title,
                detail.UpdatedAt,
                detail.Messages.Count,
                detail.Provider,
                detail.ModelName);
            UpsertConversationSummary(summary);
            await RefreshConversationListAsync();
            
            // Defer navigation and scrolling to after render to avoid lifecycle issues
            _ = InvokeAsync(async () =>
            {
                await Task.Yield(); // Let current render complete
                try
                {
                    UpdateConversationRoute(detail.Id);
                    await ScrollToBottom();
                }
                catch (Exception ex)
                {
                    Logger.LogDebug(ex, "Failed to update route or scroll after load");
                }
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load conversation {ConversationId}", conversationId);
            throw; // Re-throw to let caller handle
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isProcessing || isStreaming)
            return;

        await EnsureConversationInitializedAsync();

        var userClientId = Guid.NewGuid().ToString();
        var userMessage = new ChatMessage
        {
            ClientId = userClientId,
            Content = currentMessage,
            Sender = MessageSender.User,
            Timestamp = DateTime.UtcNow,
            IsPending = true,
            ToolsUsed = new List<string>(),
            Sources = new List<string>()
        };

        conversationHistory.Add(userMessage);
        pendingUserMessageClientId = userClientId;
        var messageToSend = currentMessage;
        currentMessage = string.Empty;
        isProcessing = true;
        isStreaming = true;

        // Create a placeholder AI message for streaming
        var assistantClientId = Guid.NewGuid().ToString();
        currentAiMessage = new ChatMessage
        {
            ClientId = assistantClientId,
            Content = string.Empty,
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow,
            IsProcessing = true,
            ProcessingType = ProcessingType.Thinking,
            IsPending = true,
            ToolsUsed = new List<string>(),
            Sources = new List<string>()
        };

        conversationHistory.Add(currentAiMessage);
        pendingAssistantMessageClientId = assistantClientId;
        StateHasChanged();
        await ScrollToBottom();

        try
        {
            if (hubConnection != null && hubConnection.State == HubConnectionState.Connected)
            {
                // Send message via SignalR for streaming
                await hubConnection.SendAsync("StreamMessage", messageToSend, currentConversationId?.ToString());
            }
            else
            {
                throw new Exception("SignalR connection is not established.");
            }
        }
        catch (Exception ex)
        {
            // Handle connection errors
            if (currentAiMessage != null)
            {
                var index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
                if (index >= 0)
                {
                    currentAiMessage = currentAiMessage with
                    {
                        Content = $"Connection error: {ex.Message}",
                        IsProcessing = false
                    };
                    conversationHistory[index] = currentAiMessage;
                }
                
                currentAiMessage = null;
                isProcessing = false;
                isStreaming = false;
            }
            StateHasChanged();
        }
    }

    private Task OnMessageTextChanged(string newValue)
    {
        currentMessage = newValue;
        return Task.CompletedTask;
    }

    private Task HandleQuickActionCallback(QuickAction action)
    {
        currentMessage = action.Prefix;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task HandleAttachmentClick()
    {
        // If no conversation is selected, create a new one first
        if (!currentConversationId.HasValue)
        {
            await HandleNewConversationAsync();
            // Wait a bit for the component to render
            await Task.Delay(100);
        }

        if (attachmentUploader is not null)
        {
            await attachmentUploader.TriggerFileSelection();
        }
    }

    private async Task HandleConversationSelectedAsync(Guid conversationId)
    {
        isSidebarOpen = false;
        if (currentConversationId == conversationId)
        {
            StateHasChanged();
            return;
        }

        if (conversationId == Guid.Empty)
        {
            await HandleNewConversationAsync();
            return;
        }

        await LoadConversationAsync(conversationId);
    }

    private async Task HandleNewConversationAsync()
    {
        try
        {
            var conversationId = await ChatService.CreateConversationAsync();
            pendingAssistantMessageClientId = null;
            pendingUserMessageClientId = null;
            isSidebarOpen = false;
            await LoadConversationAsync(conversationId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to create new conversation");
        }
    }

    private async Task HandleDeleteConversationAsync(Guid conversationId)
    {
        try
        {
            await ChatService.DeleteConversationAsync(conversationId);
            if (currentConversationId == conversationId)
            {
                currentConversationId = null;
                conversationHistory.Clear();
                currentConversationMetadata = null;
                ClearConversationRoute();
            }
            await RefreshConversationListAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to delete conversation {ConversationId}", conversationId);
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task HandleArchiveConversationAsync(Guid conversationId)
    {
        try
        {
            var metadata = await ChatService.ArchiveConversationAsync(conversationId);
            await RefreshConversationListAsync();

            if (currentConversationId == conversationId)
            {
                currentConversationId = null;
                currentConversationMetadata = null;
                conversationHistory.Clear();
                ClearConversationRoute();
            }
            else if (metadata != null && currentConversationMetadata?.Id == conversationId)
            {
                currentConversationMetadata = metadata;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to archive conversation {ConversationId}", conversationId);
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task HandleConversationTitleChangedAsync(string newTitle)
    {
        if (!currentConversationId.HasValue)
        {
            return;
        }

        try
        {
            var updated = await ChatService.UpdateConversationAsync(currentConversationId.Value, newTitle, null);
            if (updated != null)
            {
                currentConversationMetadata = updated;
                await RefreshConversationListAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update conversation title for {ConversationId}", currentConversationId);
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task HandleExportConversationAsync()
    {
        if (!currentConversationId.HasValue)
        {
            return;
        }

        try
        {
            var exportContent = await ChatService.ExportConversationAsync(currentConversationId.Value);
            if (string.IsNullOrWhiteSpace(exportContent))
            {
                return;
            }

            var fileName = CreateExportFileName(currentConversationMetadata?.Title, currentConversationId.Value);
            await jsRuntime.InvokeVoidAsync("downloadFile", fileName, "application/json", exportContent);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to export conversation {ConversationId}", currentConversationId);
        }
    }

    private void CloseSidebar()
    {
        isSidebarOpen = false;
        StateHasChanged();
    }

    private async Task HandleMetadataAsync(string metadataJson)
    {
        StreamingMetadata? metadata = null;
        try
        {
            metadata = JsonSerializer.Deserialize<StreamingMetadata>(metadataJson, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });
        }
        catch (JsonException ex)
        {
            Logger.LogError(ex, "Invalid metadata payload: {Metadata}", metadataJson);
            return;
        }

        if (metadata == null)
        {
            return;
        }

        await InvokeAsync(() =>
        {
            var conversationId = metadata.ConversationId;
            if (!currentConversationId.HasValue || currentConversationId != conversationId)
            {
                currentConversationId = conversationId;
                UpdateConversationRoute(conversationId);
            }

            PromoteUserMessage(metadata);
            PromoteAssistantMessage(metadata);

            if (currentConversationMetadata != null)
            {
                currentConversationMetadata = currentConversationMetadata with
                {
                    UpdatedAt = DateTime.UtcNow,
                    MessageCount = conversationHistory.Count
                };
            }

            UpdateCurrentConversationSummarySnapshot();
            _ = RefreshConversationListAsync();
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private void AddOptimisticConversationSummary(Guid conversationId)
    {
        var provider = string.IsNullOrWhiteSpace(llmProvider) ? "Assistant" : llmProvider;
        var summary = new ConversationSummary(
            conversationId,
            BuildDefaultConversationTitle(),
            DateTime.UtcNow,
            0,
            provider,
            currentConversationMetadata?.ModelName ?? string.Empty);

        UpsertConversationSummary(summary);
        StateHasChanged();
    }

    private void UpsertConversationSummary(ConversationSummary summary)
    {
        var existingIndex = conversationSummaries.FindIndex(c => c.Id == summary.Id);
        if (existingIndex >= 0)
        {
            conversationSummaries[existingIndex] = summary;
        }
        else
        {
            conversationSummaries.Insert(0, summary);
        }
    }

    private void UpdateCurrentConversationSummarySnapshot()
    {
        if (!currentConversationId.HasValue)
        {
            return;
        }

        var provider = currentConversationMetadata?.Provider ?? (string.IsNullOrWhiteSpace(llmProvider) ? "Assistant" : llmProvider);
        var modelName = currentConversationMetadata?.ModelName ?? string.Empty;
        var title = currentConversationMetadata?.Title ?? BuildDefaultConversationTitle();
        var updatedAt = currentConversationMetadata?.UpdatedAt ?? DateTime.UtcNow;

        var summary = new ConversationSummary(
            currentConversationId.Value,
            title,
            updatedAt,
            conversationHistory.Count,
            provider,
            modelName);

        UpsertConversationSummary(summary);
    }

    private static string BuildDefaultConversationTitle(string? source = null)
    {
        if (!string.IsNullOrWhiteSpace(source))
        {
            var trimmed = source.Trim();
            const int MaxLength = 80;
            if (trimmed.Length <= MaxLength)
            {
                return trimmed;
            }

            return trimmed.Substring(0, MaxLength) + "‚Ä¶";
        }

        return $"Chat - {DateTime.UtcNow:MMM d, yyyy HH:mm}";
    }

    private void UpdateConversationRoute(Guid conversationId)
    {
        try
        {
            var target = NavigationManager.GetUriWithQueryParameter("conversationId", conversationId.ToString());
            Logger.LogInformation("Updating conversation route to: {Target}", target);
            NavigationManager.NavigateTo(target);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update conversation route for {ConversationId}", conversationId);
        }
    }

    private void ClearConversationRoute()
    {
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        if (string.IsNullOrEmpty(uri.Query))
        {
            return;
        }

        var baseUri = uri.GetLeftPart(UriPartial.Path);
        NavigationManager.NavigateTo(baseUri);
    }

    private static string CreateExportFileName(string? title, Guid conversationId)
    {
        var sanitizedTitle = SanitizeFileName(string.IsNullOrWhiteSpace(title) ? "conversation" : title);
        return $"{sanitizedTitle}-{conversationId}.json";
    }

    private static string SanitizeFileName(string name)
    {
        var invalidChars = Path.GetInvalidFileNameChars();
        var cleaned = new string(name.Select(ch => invalidChars.Contains(ch) ? '-' : ch).ToArray());
        return string.IsNullOrWhiteSpace(cleaned) ? "conversation" : cleaned;
    }

    private async Task HandleActionConfirmed(string actionId)
    {
        // Find the message with this action card
        var message = conversationHistory.FirstOrDefault(m => m.ActionCard?.Id == actionId);
        if (message == null || message.ActionCard == null) return;

        // Check if this is a server-side ActionCard (from reflection middleware)
        if (!string.IsNullOrEmpty(message.ActionCard.ReflectionKey))
        {
            await HandleServerSideActionCardConfirmation(message, message.ActionCard.ReflectionKey);
            return;
        }

        // Original client-side ActionCard handling
        // Update the action card status to Processing
        message = message with
        {
            ActionCard = message.ActionCard with
            {
                Status = ActionCardStatus.Processing
            }
        };

        // Update in the list
        var index = conversationHistory.IndexOf(conversationHistory.First(m => m.ActionCard?.Id == actionId));
        conversationHistory[index] = message;
        StateHasChanged();

        await PersistMessageArtifactsAsync(message);

        FileOperationData? persistedFileOperation = null;
        try
        {
            // Route single-file actions to Modify; multi-file to Reorganize
            if (message.ActionCard.Actions.Count == 1)
            {
                var action = message.ActionCard.Actions[0];
                var modifyRequest = new ModifyRequest
                {
                    Operation = action.Operation,
                    FilePath = action.Source,
                    Content = action.Content,
                    ConfirmationId = actionId
                };

                var response = await ChatService.ModifyAsync(modifyRequest);
                if (response.Success && !string.IsNullOrWhiteSpace(response.FilePath))
                {
                    persistedFileOperation = new FileOperationData
                    {
                        Action = action.Operation,
                        FilePath = response.FilePath
                    };
                }

                // Update the action card with the result
                message = message with
                {
                    ActionCard = message.ActionCard with
                    {
                        Status = response.Success ? ActionCardStatus.Completed : ActionCardStatus.Failed,
                        StatusMessage = response.Message
                    }
                };
            }
            else
            {
                // Multi-action: use existing Reorganize flow
                var reorganizeRequest = new ReorganizeRequest
                {
                    Operation = message.ActionCard.OperationType.ToString(),
                    FileOperations = message.ActionCard.Actions.Select(a => new FileOperation
                    {
                        SourcePath = a.Source,
                        DestinationPath = a.Destination,
                        Operation = a.Type.ToString()
                    }).ToList(),
                    ConfirmationId = actionId
                };

                var response = await ChatService.ReorganizeAsync(reorganizeRequest);

                message = message with
                {
                    ActionCard = message.ActionCard with
                    {
                        Status = response.Success ? ActionCardStatus.Completed : ActionCardStatus.Failed,
                        StatusMessage = response.Message
                    }
                };
            }

            conversationHistory[index] = message;
        }
        catch (Exception ex)
        {
            message = message with
            {
                ActionCard = message.ActionCard! with
                {
                    Status = ActionCardStatus.Failed,
                    StatusMessage = $"Failed to execute actions: {ex.Message}"
                }
            };

            conversationHistory[index] = message;
        }

        await PersistMessageArtifactsAsync(message, persistedFileOperation);
        StateHasChanged();
    }

    private async Task HandleServerSideActionCardConfirmation(ChatMessage message, string reflectionKey)
    {
        // Update status to Processing
        var index = conversationHistory.IndexOf(message);
        if (index < 0) return;

        message = message with
        {
            ActionCard = message.ActionCard! with { Status = ActionCardStatus.Processing }
        };
        conversationHistory[index] = message;
        StateHasChanged();

        try
        {
            Logger?.LogInformation("Confirming server-side ActionCard with reflection key: {ReflectionKey}", reflectionKey);

            // Call the new ActionCard confirmation API endpoint
            var apiUrl = $"http://localhost:5095/actioncards/{reflectionKey}/confirm";
            var response = await HttpClient.PostAsync(apiUrl, null);
            
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadAsStringAsync();
                Logger?.LogInformation("ActionCard confirmation successful: {Result}", result);

                message = message with
                {
                    ActionCard = message.ActionCard! with
                    {
                        Status = ActionCardStatus.Completed,
                        StatusMessage = "Operation completed successfully"
                    }
                };
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                Logger?.LogError("ActionCard confirmation failed: {Error}", errorMessage);

                message = message with
                {
                    ActionCard = message.ActionCard! with
                    {
                        Status = ActionCardStatus.Failed,
                        StatusMessage = $"Operation failed: {errorMessage}"
                    }
                };
            }
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Failed to confirm server-side ActionCard");

            message = message with
            {
                ActionCard = message.ActionCard! with
                {
                    Status = ActionCardStatus.Failed,
                    StatusMessage = $"Error: {ex.Message}"
                }
            };
        }

        conversationHistory[index] = message;
        StateHasChanged();
    }

    private async Task HandleServerSideActionCardCancellation(ChatMessage message, string reflectionKey)
    {
        var index = conversationHistory.IndexOf(message);
        if (index < 0) return;

        try
        {
            Logger?.LogInformation("Cancelling server-side ActionCard with reflection key: {ReflectionKey}", reflectionKey);

            // Call the ActionCard cancellation API endpoint
            var apiUrl = $"http://localhost:5095/actioncards/{reflectionKey}/cancel";
            var response = await HttpClient.PostAsync(apiUrl, null);
            
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadAsStringAsync();
                Logger?.LogInformation("ActionCard cancellation successful: {Result}", result);

                message = message with
                {
                    ActionCard = message.ActionCard! with
                    {
                        Status = ActionCardStatus.Cancelled,
                        StatusMessage = "Operation cancelled by user"
                    }
                };
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                Logger?.LogWarning("ActionCard cancellation failed: {Error}", errorMessage);

                // Still mark as cancelled even if API call failed
                message = message with
                {
                    ActionCard = message.ActionCard! with
                    {
                        Status = ActionCardStatus.Cancelled,
                        StatusMessage = "Operation cancelled (cleanup may have failed)"
                    }
                };
            }
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Failed to cancel server-side ActionCard");

            // Still mark as cancelled even if exception occurred
            message = message with
            {
                ActionCard = message.ActionCard! with
                {
                    Status = ActionCardStatus.Cancelled,
                    StatusMessage = "Operation cancelled (error during cleanup)"
                }
            };
        }

        conversationHistory[index] = message;
        StateHasChanged();
        await PersistMessageArtifactsAsync(message);
    }

    private async Task HandleActionCancelled(string actionId)
    {
        // Find the message with this action card
        var message = conversationHistory.FirstOrDefault(m => m.ActionCard?.Id == actionId);
        if (message != null && message.ActionCard != null)
        {
            // Check if this is a server-side ActionCard (has ReflectionKey)
            if (!string.IsNullOrEmpty(message.ActionCard.ReflectionKey))
            {
                await HandleServerSideActionCardCancellation(message, message.ActionCard.ReflectionKey);
            }
            else
            {
                // Client-side ActionCard - just update status
                message = message with
                {
                    ActionCard = message.ActionCard with
                    {
                        Status = ActionCardStatus.Cancelled,
                        StatusMessage = "Action cancelled by user"
                    }
                };

                // Update in the list
                var index = conversationHistory.IndexOf(conversationHistory.First(m => m.ActionCard?.Id == actionId));
                conversationHistory[index] = message;

                StateHasChanged();

                await PersistMessageArtifactsAsync(message);
            }
        }
    }

    private async Task HandleActionEdit(string actionId)
    {
        // For now, just show a message
        // In a real implementation, this would open an edit dialog
        var editMessage = new ChatMessage
        {
            Content = "Edit functionality not yet implemented. Please cancel and retry with a different request.",
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow
        };

        conversationHistory.Add(editMessage);
        StateHasChanged();
        await ScrollToBottom();
    }

    private async Task PersistMessageArtifactsAsync(ChatMessage message, FileOperationData? fileOperation = null)
    {
        if (!Guid.TryParse(message.Id, out var messageId))
        {
            return;
        }

        ActionCardUpdate? actionCardUpdate = null;
        if (message.ActionCard != null)
        {
            var plannedActions = message.ActionCard.Actions
                .Select((action, index) => new PlannedActionUpdate(
                    null,
                    action.Type.ToString(),
                    string.IsNullOrWhiteSpace(action.Source) ? null : action.Source,
                    string.IsNullOrWhiteSpace(action.Destination) ? null : action.Destination,
                    string.IsNullOrWhiteSpace(action.Description) ? null : action.Description,
                    action.Operation,
                    string.IsNullOrWhiteSpace(action.Content) ? null : action.Content,
                    index))
                .ToList();

            var operation = message.ActionCard.Actions.FirstOrDefault()?.Operation;
            if (string.IsNullOrWhiteSpace(operation))
            {
                operation = message.ActionCard.OperationType.ToString().ToLowerInvariant();
            }
            var completedAt = message.ActionCard.Status is ActionCardStatus.Completed or ActionCardStatus.Failed or ActionCardStatus.Cancelled
                ? DateTime.UtcNow
                : (DateTime?)null;

            actionCardUpdate = new ActionCardUpdate(
                Guid.TryParse(message.ActionCard.Id, out var cardId) ? cardId : null,
                message.ActionCard.Title,
                message.ActionCard.Status.ToString(),
                operation,
                message.ActionCard.StatusMessage,
                message.Timestamp,
                completedAt,
                plannedActions);
        }

        FileOperationUpdate? fileOperationUpdate = null;
        if (fileOperation != null && !string.IsNullOrWhiteSpace(fileOperation.Action) && !string.IsNullOrWhiteSpace(fileOperation.FilePath))
        {
            fileOperationUpdate = new FileOperationUpdate(fileOperation.Action, fileOperation.FilePath, DateTime.UtcNow);
        }

        if (actionCardUpdate is null && fileOperationUpdate is null)
        {
            return;
        }

        try
        {
            var update = new MessageArtifactsUpdate(actionCardUpdate, fileOperationUpdate);
            var artifactRequest = new ArtifactUpdateRequest { Artifacts = update };
            await ChatService.UpdateMessageArtifactsAsync(messageId, artifactRequest);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to persist artifacts for message {MessageId}", messageId);
        }
    }

    private Task ParseResponseForComponents(string response)
    {
        if (string.IsNullOrWhiteSpace(response))
        {
            return Task.CompletedTask;
        }

        if (response.Length > 10_000)
        {
            Logger?.LogWarning("Assistant response too large for parsing ({Length})", response.Length);
            return Task.CompletedTask;
        }

        try
        {
            if (ContainsConfirmationKeywords(response))
            {
                var fileOpMatch = FileOpPattern1.Match(response);

                if (!fileOpMatch.Success)
                {
                    fileOpMatch = FileOpPattern2.Match(response);
                }

                if (fileOpMatch.Success)
                {
                    var operation = fileOpMatch.Groups[1].Value.Trim();
                    string content;
                    string filePath;

                    if (response.Contains("with content:", StringComparison.OrdinalIgnoreCase))
                    {
                        filePath = fileOpMatch.Groups[2].Value.Trim();
                        content = fileOpMatch.Groups[3].Value.Trim();
                    }
                    else
                    {
                        content = fileOpMatch.Groups[2].Value.Trim();
                        filePath = fileOpMatch.Groups[3].Value.Trim();
                    }

                    var actionCard = new ActionCardData
                    {
                        Id = Guid.NewGuid().ToString(),
                        Title = $"{char.ToUpper(operation[0])}{operation.Substring(1).ToLower()} Content",
                        OperationType = operation.ToLowerInvariant() switch
                        {
                            "append" => ActionOperationType.Other,
                            "create" => ActionOperationType.Create,
                            "delete" => ActionOperationType.Delete,
                            _ => ActionOperationType.Other
                        },
                        Actions = new List<PlannedAction>
                        {
                            new PlannedAction
                            {
                                Type = operation.ToLowerInvariant() switch
                                {
                                    "append" => ActionType.Modify,
                                    "create" => ActionType.Create,
                                    "delete" => ActionType.Delete,
                                    "modify" => ActionType.Modify,
                                    "patch" => ActionType.Modify,
                                    "write" => ActionType.Modify,
                                    _ => ActionType.Other
                                },
                                Source = filePath,
                                Destination = filePath,
                                Content = content,
                                Operation = operation.ToLowerInvariant(),
                                Description = $"{char.ToUpper(operation[0])}{operation.Substring(1).ToLower()} \"{content}\" ‚Üí {filePath}"
                            }
                        },
                        Status = ActionCardStatus.Pending
                    };

                    AttachActionCard(actionCard);
                    return Task.CompletedTask;
                }
            }

            var completedOpMatch = CompletedOpPattern.Match(response);
            if (completedOpMatch.Success)
            {
                var action = completedOpMatch.Groups[1].Value.Trim();
                var filePath = completedOpMatch.Groups[2].Value.Trim();

                var fileOperationData = new FileOperationData
                {
                    Action = char.ToUpper(action[0]) + action.Substring(1),
                    FilePath = filePath
                };

                AttachFileOperation(fileOperationData);
            }
        }
        catch (RegexMatchTimeoutException ex)
        {
            Logger?.LogError(ex, "Regex timeout while parsing assistant response");
        }

        return Task.CompletedTask;
    }

    private void AttachActionCard(ActionCardData actionCard)
    {
        var index = -1;
        if (currentAiMessage != null)
        {
            index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
        }
        if (index < 0)
        {
            index = conversationHistory.FindLastIndex(m => m.Sender == MessageSender.AI);
        }

        if (index >= 0)
        {
            var msg = conversationHistory[index];
            var updated = msg with
            {
                ActionCard = actionCard,
                ProcessingType = ProcessingType.None
            };
            conversationHistory[index] = updated;

            if (currentAiMessage != null && currentAiMessage.ClientId == msg.ClientId)
            {
                currentAiMessage = updated;
            }

            StateHasChanged();
        }
    }

    private void AttachFileOperation(FileOperationData fileOperationData)
    {
        var index = -1;
        if (currentAiMessage != null)
        {
            index = conversationHistory.FindLastIndex(m => m.ClientId == currentAiMessage.ClientId);
        }
        if (index < 0)
        {
            index = conversationHistory.FindLastIndex(m => m.Sender == MessageSender.AI);
        }

        if (index >= 0)
        {
            var msg = conversationHistory[index];
            var updated = msg with
            {
                FileOperation = fileOperationData,
                ProcessingType = ProcessingType.None
            };
            conversationHistory[index] = updated;

            if (currentAiMessage != null && currentAiMessage.ClientId == msg.ClientId)
            {
                currentAiMessage = updated;
            }

            StateHasChanged();
        }
    }

    private static bool ContainsConfirmationKeywords(string text)
    {
        var lower = text.ToLowerInvariant();
        return lower.Contains("confirm") ||
        lower.Contains("confirmation") ||
        lower.Contains("proceed") ||
        lower.Contains("are you sure") ||
        lower.Contains("please verify") ||
        lower.Contains("i will perform") ||
        lower.Contains("planned operations");
    }

    private static ActionOperationType DetermineOperationType(List<PlannedAction> actions)
    {
        if (actions.All(a => a.Type == ActionType.Move))
            return ActionOperationType.Move;
        if (actions.All(a => a.Type == ActionType.Delete))
            return ActionOperationType.Delete;
        if (actions.All(a => a.Type == ActionType.Create))
            return ActionOperationType.Create;
        if (actions.Count > 3)
            return ActionOperationType.Reorganize;
        return ActionOperationType.Other;
    }

    private static bool ExtractPaths(string text, out List<string> paths)
    {
        paths = ExtractAllPaths(text);
        return paths.Count >= 2;
    }

    private static List<string> ExtractAllPaths(string text)
    {
        var results = new HashSet<string>();

        // Pattern 1: Quoted paths
        var quotedMatches = System.Text.RegularExpressions.Regex.Matches(text, @"""([^""]+\.[a-zA-Z0-9]+)""");
        foreach (System.Text.RegularExpressions.Match m in quotedMatches)
        {
            results.Add(m.Groups[1].Value);
        }

        // Pattern 2: Backtick paths
        var backtickMatches = System.Text.RegularExpressions.Regex.Matches(text, @"`([^`]+\.[a-zA-Z0-9]+)`");
        foreach (System.Text.RegularExpressions.Match m in backtickMatches)
        {
            results.Add(m.Groups[1].Value);
        }

        // Pattern 3: Paths with slashes and extensions
        var slashMatches = System.Text.RegularExpressions.Regex.Matches(text, @"([\w\-./\\]+\.[a-zA-Z0-9]+)");
        foreach (System.Text.RegularExpressions.Match m in slashMatches)
        {
            var path = m.Groups[1].Value.Trim();
            if (!path.StartsWith("http") && !path.StartsWith("www"))
            {
                results.Add(path);
            }
        }

        return results.ToList();
    }

    private static ChatMessage AttachMicrosoftLearnSources(ChatMessage message, string response, ILogger? logger)
    {
        if (message.ToolsUsed == null || message.ToolsUsed.Count == 0)
        {
            return message;
        }

        if (!message.ToolsUsed.Any(IsMicrosoftLearnToolName))
        {
            return message;
        }

        var extracted = ExtractMicrosoftLearnSources(response, logger);
        if (extracted.Count == 0)
        {
            return message;
        }

    var existingCount = message.Sources?.Count ?? 0;
    var merged = MergeSources(message.Sources, extracted);
    if (merged.Count == existingCount)
        {
            return message;
        }

        return message with { Sources = merged };
    }

    private static List<string> ExtractMicrosoftLearnSources(string response, ILogger? logger)
    {
        var results = new List<string>();
        if (string.IsNullOrWhiteSpace(response))
        {
            return results;
        }

        try
        {
            foreach (System.Text.RegularExpressions.Match match in MicrosoftLearnUrlPattern.Matches(response))
            {
                var normalized = NormalizeSourceUrl(match.Value);
                if (string.IsNullOrEmpty(normalized))
                {
                    continue;
                }

                if (!Uri.TryCreate(normalized, UriKind.Absolute, out var uri))
                {
                    continue;
                }

                if (!IsMicrosoftLearnHost(uri.Host))
                {
                    continue;
                }

                var absolute = uri.AbsoluteUri;
                if (!results.Any(existing => string.Equals(existing, absolute, StringComparison.OrdinalIgnoreCase)))
                {
                    results.Add(absolute);
                }
            }
        }
        catch (RegexMatchTimeoutException ex)
        {
            logger?.LogDebug(ex, "Timeout while extracting Microsoft Learn sources.");
        }

        return results;
    }

    private static List<string> MergeSources(List<string>? existingSources, IReadOnlyCollection<string> newSources)
    {
        var merged = existingSources is { Count: > 0 }
            ? new List<string>(existingSources)
            : new List<string>();

        foreach (var source in newSources)
        {
            if (!merged.Any(existing => string.Equals(existing, source, StringComparison.OrdinalIgnoreCase)))
            {
                merged.Add(source);
            }
        }

        return merged;
    }

    private static bool IsMicrosoftLearnHost(string? host)
    {
        if (string.IsNullOrWhiteSpace(host))
        {
            return false;
        }

        return MicrosoftLearnHosts.Any(known =>
            host.Equals(known, StringComparison.OrdinalIgnoreCase) ||
            host.EndsWith($".{known}", StringComparison.OrdinalIgnoreCase));
    }

    private static bool IsMicrosoftLearnToolName(string? toolName) =>
        !string.IsNullOrWhiteSpace(toolName) &&
        toolName.StartsWith("microsoft_", StringComparison.OrdinalIgnoreCase);

    private static string NormalizeSourceUrl(string url)
    {
        if (string.IsNullOrWhiteSpace(url))
        {
            return string.Empty;
        }

        var trimmed = url.Trim();
        trimmed = trimmed.TrimStart('(', '[', '{', '<', '\'', '"');
        trimmed = trimmed.TrimEnd('.', ',', ';', '!', '?', ')', ']', '}', '>', '\'', '"');
        return trimmed;
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await Task.Delay(100); // Small delay to ensure DOM is updated
            await jsRuntime.InvokeVoidAsync("scrollToBottom");
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("prerendering"))
        {
            // Ignore errors during prerendering - will be called again after render
            Logger.LogDebug("ScrollToBottom skipped during prerendering");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to scroll to bottom");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private void OpenVault()
    {
        isVaultBrowserOpen = true;
        StateHasChanged();
    }

    private void CloseVaultBrowser()
    {
        isVaultBrowserOpen = false;
        StateHasChanged();
    }

    private async Task HandleFileSelected(VaultItemData file)
    {
        // Insert file reference into chat message with explicit instruction
        // Use the exact path from the vault for the AI to match
        currentMessage = $"Read the file \"{file.Path}\"";
        isVaultBrowserOpen = false;
        StateHasChanged();
        
        // Auto-send the message
        await SendMessage();
    }

    private async Task HandleAttachmentUploaded()
    {
        // Refresh conversation metadata if needed
        await RefreshConversationListAsync();
        StateHasChanged();
    }

    private void OpenSettings()
    {
        var settingsMessage = new ChatMessage
        {
            Content = "Settings feature is coming soon!",
            Sender = MessageSender.AI,
            Timestamp = DateTime.UtcNow
        };
        conversationHistory.Add(settingsMessage);
        StateHasChanged();
    }

    private async Task ShowHistory()
    {
        isSidebarOpen = true;
        StateHasChanged();

        if (!isLoadingConversations)
        {
            try
            {
                await RefreshConversationListAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to refresh conversations when opening history");
            }
        }
    }

    private void DismissPrivacyWarning()
    {
        isPrivacyWarningDismissed = true;
        StateHasChanged();
    }

    private void PromoteUserMessage(StreamingMetadata metadata)
    {
        if (!metadata.UserMessageId.HasValue || metadata.UserMessageId.Value == Guid.Empty)
        {
            return;
        }

        var serverId = metadata.UserMessageId.Value.ToString();
        var clientId = pendingUserMessageClientId;
        var userIndex = -1;

        if (!string.IsNullOrEmpty(clientId))
        {
            userIndex = conversationHistory.FindLastIndex(m => m.ClientId == clientId);
        }

        if (userIndex < 0)
        {
            userIndex = conversationHistory.FindLastIndex(m => m.IsPending && m.Sender == MessageSender.User);
        }

        if (userIndex >= 0)
        {
            conversationHistory[userIndex] = conversationHistory[userIndex] with
            {
                Id = serverId,
                IsPending = false
            };
        }

        pendingUserMessageClientId = null;
    }

    private void PromoteAssistantMessage(StreamingMetadata metadata)
    {
        if (!metadata.AssistantMessageId.HasValue || metadata.AssistantMessageId.Value == Guid.Empty)
        {
            return;
        }

        var serverId = metadata.AssistantMessageId.Value.ToString();
        var clientId = pendingAssistantMessageClientId;
        var assistantIndex = -1;

        if (!string.IsNullOrEmpty(clientId))
        {
            assistantIndex = conversationHistory.FindLastIndex(m => m.ClientId == clientId);
        }

        if (assistantIndex < 0)
        {
            assistantIndex = conversationHistory.FindLastIndex(m => m.IsPending && m.Sender == MessageSender.AI);
        }

        if (assistantIndex >= 0)
        {
            var updatedMessage = conversationHistory[assistantIndex] with
            {
                Id = serverId,
                IsPending = false
            };

            if (metadata.FileOperation != null)
            {
                updatedMessage = updatedMessage with
                {
                    FileOperation = new FileOperationData
                    {
                        Action = metadata.FileOperation.Action,
                        FilePath = metadata.FileOperation.FilePath
                    }
                };
            }

            conversationHistory[assistantIndex] = updatedMessage;
            currentAiMessage = updatedMessage;
        }

        pendingAssistantMessageClientId = null;
    }

    private sealed record StreamingMetadata(Guid ConversationId, Guid? UserMessageId, Guid? AssistantMessageId, StreamingFileOperation? FileOperation);

    private sealed record StreamingFileOperation(string Action, string FilePath);

    private Task HandleServerActionCardAsync(string actionCardJson)
    {
        return InvokeAsync(() =>
        {
            try
            {
                Logger?.LogInformation("Received ActionCard from reflection middleware: {Json}", actionCardJson);

                // Parse the ActionCard JSON
                var jsonDoc = System.Text.Json.JsonDocument.Parse(actionCardJson);
                var root = jsonDoc.RootElement;

                // Extract ActionCard properties
                var id = root.GetProperty("id").GetString() ?? Guid.NewGuid().ToString();
                var title = root.GetProperty("title").GetString() ?? "Operation Confirmation";
                var operation = root.GetProperty("operation").GetString() ?? "modify";
                
                // Parse planned actions
                var plannedActions = new List<PlannedAction>();
                if (root.TryGetProperty("plannedActions", out var actionsArray))
                {
                    foreach (var actionEl in actionsArray.EnumerateArray())
                    {
                        var action = new PlannedAction
                        {
                            Type = Enum.TryParse<ActionType>(actionEl.GetProperty("type").GetString(), true, out var at) ? at : ActionType.Other,
                            Source = actionEl.GetProperty("source").GetString() ?? string.Empty,
                            Destination = actionEl.GetProperty("destination").GetString() ?? string.Empty,
                            Description = actionEl.GetProperty("description").GetString() ?? string.Empty,
                            Operation = actionEl.GetProperty("operation").GetString() ?? string.Empty,
                            Content = actionEl.TryGetProperty("content", out var contentEl) ? contentEl.GetString() ?? string.Empty : string.Empty
                        };
                        plannedActions.Add(action);
                    }
                }

                // Extract reflection key and metadata (server-side ActionCards only)
                string? reflectionKey = null;
                string? reflectionReasoning = null;
                List<string>? reflectionWarnings = null;
                
                if (root.TryGetProperty("reflectionMetadata", out var metadata))
                {
                    if (metadata.TryGetProperty("reflectionKey", out var keyEl))
                    {
                        reflectionKey = keyEl.GetString();
                        Logger?.LogInformation("ActionCard has reflection key: {ReflectionKey}", reflectionKey);
                    }
                    
                    if (metadata.TryGetProperty("reasoning", out var reasoningEl))
                    {
                        reflectionReasoning = reasoningEl.GetString();
                    }
                    
                    if (metadata.TryGetProperty("warnings", out var warningsEl))
                    {
                        reflectionWarnings = new List<string>();
                        foreach (var warning in warningsEl.EnumerateArray())
                        {
                            reflectionWarnings.Add(warning.GetString() ?? string.Empty);
                        }
                    }
                }

                // Create ActionCard data
                var actionCard = new ActionCardData
                {
                    Id = id,
                    Title = title,
                    OperationType = operation.ToLowerInvariant() switch
                    {
                        "delete" => ActionOperationType.Delete,
                        "move" => ActionOperationType.Move,
                        "patch" => ActionOperationType.Other,
                        _ => ActionOperationType.Other
                    },
                    Actions = plannedActions,
                    Status = ActionCardStatus.Pending,
                    StatusMessage = string.Empty,
                    ReflectionKey = reflectionKey,
                    ReflectionReasoning = reflectionReasoning,
                    ReflectionWarnings = reflectionWarnings
                };

                // Attach to current AI message
                AttachActionCard(actionCard);
                
                Logger?.LogInformation("Successfully created ActionCard with {Count} actions", plannedActions.Count);
            }
            catch (Exception ex)
            {
                Logger?.LogError(ex, "Failed to parse ActionCard from reflection middleware");
            }
        });
    }
}