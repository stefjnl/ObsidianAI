@using ObsidianAI.Web.Models
@using ObsidianAI.Web.Services
@inject IChatService ChatService
@inject IVaultService VaultService
@inject ILogger<VaultBrowser> Logger
@inject IJSRuntime JS

<div class="vault-browser @(IsOpen ? "vault-browser-open" : "")" 
     style="--vault-browser-width: @(BrowserWidth)px;">
    <!-- Resize Handle for entire vault browser -->
    <div class="vault-browser-resize-handle @(_isBrowserResizing ? "resizing" : "")"
         @ref="_resizeHandleRef"
         @onmousedown="StartBrowserResize"
         @onmousedown:preventDefault="true">
        <div class="vault-browser-resize-handle-indicator"></div>
    </div>
    
    <div class="vault-browser-header">
        <h2>üìÅ Vault Browser</h2>
        <button class="vault-close-btn" type="button" @onclick="OnClose" aria-label="Close vault browser">‚úï</button>
    </div>

    <div class="vault-browser-body">
        <!-- File Tree Panel (Flexible) - LEFT SIDE -->
        <div class="vault-browser-content @(string.IsNullOrEmpty(selectedFilePath) ? "vault-browser-content-full" : "")">
            @if (IsLoading)
            {
                <div class="vault-loading">
                    <div class="vault-loading-spinner"></div>
                    <p>Loading vault contents...</p>
                </div>
            }
            else if (HasError)
            {
                <div class="vault-error">
                    <p>‚ö†Ô∏è Failed to load vault contents</p>
                    <button class="btn btn-secondary" @onclick="() => LoadVaultContents()">Retry</button>
                </div>
            }
            else if (Items.Count == 0)
            {
                <div class="vault-empty">
                    <p>üì≠ No files found in vault</p>
                </div>
            }
            else
            {
                <div class="vault-breadcrumb">
                    <button class="vault-breadcrumb-btn" @onclick="() => LoadVaultContents(null)">
                        üè† Root
                    </button>
                </div>

                <div class="vault-tree">
                    @foreach (var item in Items)
                    {
                        <VaultTreeNode Item="item" Level="0" OnItemClick="HandleItemClick" OnFolderExpand="HandleFolderExpand" />
                    }
                </div>
            }
        </div>

        @if (!string.IsNullOrEmpty(selectedFilePath))
        {
            <!-- File Viewer Panel - Overlays on left side -->
            <div class="vault-file-viewer">
                <FileViewer FilePath="@selectedFilePath"
                           FileContent="@selectedFileContent"
                           IsLoading="@isLoadingFile"
                           ErrorMessage="@fileErrorMessage"
                           OnClose="CloseFileViewer" />
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public bool IsOpen { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback<VaultItemData> OnFileSelected { get; set; }

    private List<VaultItemData> Items { get; set; } = new();
    private bool IsLoading { get; set; }
    private bool HasError { get; set; }
    private string CurrentPath { get; set; } = "/";
    private string? selectedFilePath;
    private string? selectedFileContent;
    private bool isLoadingFile;
    private string? fileErrorMessage;

    // Browser container resizing properties
    private ElementReference _resizeHandleRef;
    private DotNetObjectReference<VaultBrowser>? _dotNetHelper;
    private double BrowserWidth { get; set; } = 480; // Default width in pixels
    private const double MinBrowserWidth = 300;
    private const double MaxBrowserWidth = 1200;
    private bool _isBrowserResizing;
    private double _browserStartX;
    private double _browserStartWidth;

    // File viewer resizing properties (legacy, can be removed if not needed)
    private double FileViewerWidth { get; set; } = 400;
    private const double MinFileViewerWidth = 250;
    private const double MaxFileViewerWidth = 800;
    private bool _isResizing;
    private double _startX;
    private double _startWidth;

    protected override async Task OnParametersSetAsync()
    {
        if (IsOpen && Items.Count == 0 && !IsLoading)
        {
            await LoadVaultContents();
        }
    }

    private async Task LoadVaultContents(string? path = null)
    {
        IsLoading = true;
        HasError = false;
        StateHasChanged();

        try
        {
            var contents = await ChatService.BrowseVaultAsync(path);
            Items = ProcessVaultItems(contents.Items);
            CurrentPath = contents.CurrentPath;
            Logger.LogInformation("Loaded {Count} items from vault path: {Path}", Items.Count, CurrentPath);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load vault contents for path: {Path}", path);
            HasError = true;
            Items = new List<VaultItemData>();
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private List<VaultItemData> ProcessVaultItems(List<VaultItemData> items)
    {
        // Items are already sorted from the API, just return them
        return items;
    }

    private async Task HandleFolderExpand(VaultItemData folder)
    {
        if (!folder.IsExpanded)
        {
            // Expand and load children if not already loaded
            folder.IsExpanded = true;
            StateHasChanged();

            // Only load children if they haven't been loaded yet
            if (folder.Children.Count == 0)
            {
                try
                {
                    var contents = await ChatService.BrowseVaultAsync(folder.Path);
                    folder.Children = ProcessVaultItems(contents.Items);
                    Logger.LogInformation("Loaded {Count} children for folder: {Path}", folder.Children.Count, folder.Path);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to load folder contents: {Path}", folder.Path);
                    folder.Children = new List<VaultItemData>();
                }

                StateHasChanged();
            }
        }
        else
        {
            // Collapse folder
            folder.IsExpanded = false;
            StateHasChanged();
        }
    }

    private async Task HandleItemClick(VaultItemData item)
    {
        if (item.Type == VaultItemType.File)
        {
            Logger.LogInformation("File selected: {Path}", item.Path);
            await LoadFileContentAsync(item.Path);
        }
    }

    private async Task LoadFileContentAsync(string path)
    {
        selectedFilePath = path;
        selectedFileContent = null;
        isLoadingFile = true;
        fileErrorMessage = null;
        StateHasChanged();

        try
        {
            selectedFileContent = await VaultService.ReadFileAsync(path);
            Logger.LogInformation("Successfully loaded file content for: {Path}", path);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load file content: {Path}", path);
            fileErrorMessage = $"Failed to load file: {ex.Message}";
        }
        finally
        {
            isLoadingFile = false;
            StateHasChanged();
        }
    }

    private void CloseFileViewer()
    {
        selectedFilePath = null;
        selectedFileContent = null;
        fileErrorMessage = null;
        StateHasChanged();
    }

    private void StartResize(MouseEventArgs e)
    {
        _isResizing = true;
        _startX = e.ClientX;
        _startWidth = FileViewerWidth;
        StateHasChanged();
    }

    private void StartTouchResize(TouchEventArgs e)
    {
        if (e.Touches.Length > 0)
        {
            var touch = e.Touches[0];
            _isResizing = true;
            _startX = touch.ClientX;
            _startWidth = FileViewerWidth;
            StateHasChanged();
        }
    }

    private void HandleResize(MouseEventArgs e)
    {
        if (_isResizing)
        {
            var deltaX = _startX - e.ClientX; // Inverted: drag left = positive delta = wider
            var newWidth = _startWidth + deltaX;
            FileViewerWidth = Math.Clamp(newWidth, MinFileViewerWidth, MaxFileViewerWidth);
            StateHasChanged();
        }
    }

    private void HandleTouchResize(TouchEventArgs e)
    {
        if (_isResizing && e.Touches.Length > 0)
        {
            var touch = e.Touches[0];
            var deltaX = _startX - touch.ClientX; // Inverted: drag left = positive delta = wider
            var newWidth = _startWidth + deltaX;
            FileViewerWidth = Math.Clamp(newWidth, MinFileViewerWidth, MaxFileViewerWidth);
            StateHasChanged();
        }
    }

    private void EndResize(MouseEventArgs e)
    {
        if (_isResizing)
        {
            _isResizing = false;
            StateHasChanged();
        }
    }

    private void EndResize()
    {
        if (_isResizing)
        {
            _isResizing = false;
            StateHasChanged();
        }
    }

    // Browser container resize methods
    private async Task StartBrowserResize(MouseEventArgs e)
    {
        _isBrowserResizing = true;
        _browserStartX = e.ClientX;
        _browserStartWidth = BrowserWidth;
        Logger.LogInformation("Started browser resize at X={X}, Width={Width}", e.ClientX, BrowserWidth);
        
        _dotNetHelper ??= DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("vaultBrowser.startResize", _dotNetHelper);
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleBrowserResize(double clientX)
    {
        if (_isBrowserResizing)
        {
            var deltaX = _browserStartX - clientX; // Drag left = positive delta = wider
            var newWidth = _browserStartWidth + deltaX;
            var clampedWidth = Math.Clamp(newWidth, MinBrowserWidth, MaxBrowserWidth);
            Logger.LogInformation("Resizing: StartX={StartX}, CurrentX={CurrentX}, Delta={Delta}, NewWidth={NewWidth}, Clamped={Clamped}",
                _browserStartX, clientX, deltaX, newWidth, clampedWidth);
            BrowserWidth = clampedWidth;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void EndBrowserResize()
    {
        if (_isBrowserResizing)
        {
            _isBrowserResizing = false;
            Logger.LogInformation("Ended browser resize at Width={Width}", BrowserWidth);
            StateHasChanged();
        }
    }
}