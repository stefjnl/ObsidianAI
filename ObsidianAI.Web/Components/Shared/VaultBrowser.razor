@using ObsidianAI.Web.Models
@using ObsidianAI.Web.Services
@inject IChatService ChatService
@inject IVaultService VaultService
@inject ILogger<VaultBrowser> Logger

<div class="vault-browser @(IsOpen ? "vault-browser-open" : "")">
    <div class="vault-browser-header">
        <h2>üìÅ Vault Browser</h2>
        <button class="vault-close-btn" type="button" @onclick="OnClose" aria-label="Close vault browser">‚úï</button>
    </div>

    <div class="vault-browser-body">
        @if (!string.IsNullOrEmpty(selectedFilePath))
        {
            <!-- File Viewer Panel -->
            <div class="vault-file-viewer">
                <FileViewer FilePath="@selectedFilePath"
                           FileContent="@selectedFileContent"
                           IsLoading="@isLoadingFile"
                           ErrorMessage="@fileErrorMessage"
                           OnClose="CloseFileViewer" />
            </div>
        }

        <!-- File Tree Panel -->
        <div class="vault-browser-content @(string.IsNullOrEmpty(selectedFilePath) ? "vault-browser-content-full" : "")">
            @if (IsLoading)
            {
                <div class="vault-loading">
                    <div class="vault-loading-spinner"></div>
                    <p>Loading vault contents...</p>
                </div>
            }
            else if (HasError)
            {
                <div class="vault-error">
                    <p>‚ö†Ô∏è Failed to load vault contents</p>
                    <button class="btn btn-secondary" @onclick="() => LoadVaultContents()">Retry</button>
                </div>
            }
            else if (Items.Count == 0)
            {
                <div class="vault-empty">
                    <p>üì≠ No files found in vault</p>
                </div>
            }
            else
            {
                <div class="vault-breadcrumb">
                    <button class="vault-breadcrumb-btn" @onclick="() => LoadVaultContents(null)">
                        üè† Root
                    </button>
                </div>

                <div class="vault-tree">
                    @foreach (var item in Items)
                    {
                        <VaultTreeNode Item="item" Level="0" OnItemClick="HandleItemClick" OnFolderExpand="HandleFolderExpand" />
                    }
                </div>
            }
        </div>
    </div>
</div>

@code {
    [Parameter]
    public bool IsOpen { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback<VaultItemData> OnFileSelected { get; set; }

    private List<VaultItemData> Items { get; set; } = new();
    private bool IsLoading { get; set; }
    private bool HasError { get; set; }
    private string CurrentPath { get; set; } = "/";
    private string? selectedFilePath;
    private string? selectedFileContent;
    private bool isLoadingFile;
    private string? fileErrorMessage;

    protected override async Task OnParametersSetAsync()
    {
        if (IsOpen && Items.Count == 0 && !IsLoading)
        {
            await LoadVaultContents();
        }
    }

    private async Task LoadVaultContents(string? path = null)
    {
        IsLoading = true;
        HasError = false;
        StateHasChanged();

        try
        {
            var contents = await ChatService.BrowseVaultAsync(path);
            Items = ProcessVaultItems(contents.Items);
            CurrentPath = contents.CurrentPath;
            Logger.LogInformation("Loaded {Count} items from vault path: {Path}", Items.Count, CurrentPath);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load vault contents for path: {Path}", path);
            HasError = true;
            Items = new List<VaultItemData>();
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private List<VaultItemData> ProcessVaultItems(List<VaultItemData> items)
    {
        // Items are already sorted from the API, just return them
        return items;
    }

    private async Task HandleFolderExpand(VaultItemData folder)
    {
        if (!folder.IsExpanded)
        {
            // Expand and load children if not already loaded
            folder.IsExpanded = true;
            StateHasChanged();

            // Only load children if they haven't been loaded yet
            if (folder.Children.Count == 0)
            {
                try
                {
                    var contents = await ChatService.BrowseVaultAsync(folder.Path);
                    folder.Children = ProcessVaultItems(contents.Items);
                    Logger.LogInformation("Loaded {Count} children for folder: {Path}", folder.Children.Count, folder.Path);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to load folder contents: {Path}", folder.Path);
                    folder.Children = new List<VaultItemData>();
                }

                StateHasChanged();
            }
        }
        else
        {
            // Collapse folder
            folder.IsExpanded = false;
            StateHasChanged();
        }
    }

    private async Task HandleItemClick(VaultItemData item)
    {
        if (item.Type == VaultItemType.File)
        {
            Logger.LogInformation("File selected: {Path}", item.Path);
            await LoadFileContentAsync(item.Path);
        }
    }

    private async Task LoadFileContentAsync(string path)
    {
        selectedFilePath = path;
        selectedFileContent = null;
        isLoadingFile = true;
        fileErrorMessage = null;
        StateHasChanged();

        try
        {
            selectedFileContent = await VaultService.ReadFileAsync(path);
            Logger.LogInformation("Successfully loaded file content for: {Path}", path);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load file content: {Path}", path);
            fileErrorMessage = $"Failed to load file: {ex.Message}";
        }
        finally
        {
            isLoadingFile = false;
            StateHasChanged();
        }
    }

    private void CloseFileViewer()
    {
        selectedFilePath = null;
        selectedFileContent = null;
        fileErrorMessage = null;
        StateHasChanged();
    }
}