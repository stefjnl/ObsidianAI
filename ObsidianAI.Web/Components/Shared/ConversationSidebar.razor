@using System
@using System.Collections.Generic
@using System.Linq
@using ObsidianAI.Web.Models

<div class="sidebar-overlay" @onclick="HandleOverlayClicked">
    <aside class="sidebar-panel" @onclick:stopPropagation="true">
        <header class="sidebar-header">
            <div class="sidebar-title">
                <h2>Conversation History</h2>
                <span class="sidebar-count">@GetConversationCountLabel(Conversations.Count)</span>
            </div>
            <button type="button" class="sidebar-close" @onclick="OnCloseClicked">Close</button>
        </header>

        <div class="sidebar-actions">
            <button type="button" class="sidebar-new" @onclick="NewConversation">+ New Chat</button>
            <input type="search"
                   class="sidebar-search"
                   placeholder="Search conversations"
                   @bind="searchTerm"
                   @bind:event="oninput"
                   aria-label="Search conversations" />
        </div>

        <section class="sidebar-content" aria-live="polite">
            @if (IsLoading)
            {
                <div class="sidebar-skeleton" role="status" aria-label="Loading conversations">
                    @for (var i = 0; i < 4; i++)
                    {
                        <div class="sidebar-skeleton-item">
                            <div class="sidebar-skeleton-title"></div>
                            <div class="sidebar-skeleton-meta"></div>
                        </div>
                    }
                </div>
            }
            else if (!FilteredConversations.Any())
            {
                <div class="sidebar-empty">No conversations yet. Start a new chat to begin.</div>
            }
            else
            {
                <ul class="sidebar-list">
                    @foreach (var conversation in FilteredConversations)
                    {
                        var isSelected = SelectedConversationId.HasValue && SelectedConversationId.Value == conversation.Id;
                        <li class="sidebar-item @(isSelected ? "selected" : string.Empty)">
                            <button type="button"
                                    class="sidebar-item-button"
                                    @onclick="() => SelectConversation(conversation.Id)">
                                <div class="sidebar-item-title">@conversation.Title</div>
                                <div class="sidebar-item-meta">
                                    <span>@FormatMessageCount(conversation.MessageCount)</span>
                                    <span>@FormatRelativeTime(conversation.UpdatedAt)</span>
                                    <span>@conversation.Provider</span>
                                </div>
                            </button>
                            <div class="sidebar-item-actions">
                                <button type="button"
                                        class="sidebar-archive"
                                        title="Archive conversation"
                                        @onclick="() => ArchiveConversation(conversation.Id)"
                                        @onclick:stopPropagation="true">
                                    Archive
                                </button>
                                <button type="button"
                                        class="sidebar-delete"
                                        title="Delete conversation"
                                        @onclick="() => DeleteConversation(conversation.Id)"
                                        @onclick:stopPropagation="true">
                                    Delete
                                </button>
                            </div>
                        </li>
                    }
                </ul>
            }
        </section>
    </aside>
</div>

@code {
    [Parameter]
    public IReadOnlyList<ConversationSummary> Conversations { get; set; } = Array.Empty<ConversationSummary>();

    [Parameter]
    public Guid? SelectedConversationId { get; set; }

    [Parameter]
    public bool IsLoading { get; set; }

    [Parameter]
    public EventCallback<Guid> OnConversationSelected { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback OnNewConversation { get; set; }

    [Parameter]
    public EventCallback<Guid> OnDeleteConversation { get; set; }

    [Parameter]
    public EventCallback<Guid> OnArchiveConversation { get; set; }

    private string searchTerm = string.Empty;

    private IEnumerable<ConversationSummary> FilteredConversations
    {
        get
        {
            if (string.IsNullOrWhiteSpace(searchTerm))
            {
                return Conversations;
            }

            var term = searchTerm.Trim();
            return Conversations.Where(c => MatchesSearch(c, term));
        }
    }

    private static bool MatchesSearch(ConversationSummary summary, string term)
    {
        return summary.Title.Contains(term, StringComparison.OrdinalIgnoreCase)
               || summary.ModelName.Contains(term, StringComparison.OrdinalIgnoreCase)
               || summary.Provider.Contains(term, StringComparison.OrdinalIgnoreCase);
    }

    private Task HandleOverlayClicked()
    {
        return OnClose.HasDelegate ? OnClose.InvokeAsync() : Task.CompletedTask;
    }

    private Task OnCloseClicked()
    {
        return OnClose.HasDelegate ? OnClose.InvokeAsync() : Task.CompletedTask;
    }

    private Task SelectConversation(Guid conversationId)
    {
        return OnConversationSelected.HasDelegate
            ? OnConversationSelected.InvokeAsync(conversationId)
            : Task.CompletedTask;
    }

    private Task NewConversation()
    {
        return OnNewConversation.HasDelegate
            ? OnNewConversation.InvokeAsync()
            : Task.CompletedTask;
    }

    private Task DeleteConversation(Guid conversationId)
    {
        return OnDeleteConversation.HasDelegate
            ? OnDeleteConversation.InvokeAsync(conversationId)
            : Task.CompletedTask;
    }

    private Task ArchiveConversation(Guid conversationId)
    {
        return OnArchiveConversation.HasDelegate
            ? OnArchiveConversation.InvokeAsync(conversationId)
            : Task.CompletedTask;
    }

    private static string FormatRelativeTime(DateTime timestamp)
    {
        var utcTimestamp = timestamp.Kind switch
        {
            DateTimeKind.Utc => timestamp,
            DateTimeKind.Local => timestamp.ToUniversalTime(),
            _ => DateTime.SpecifyKind(timestamp, DateTimeKind.Utc)
        };

        var delta = DateTime.UtcNow - utcTimestamp;
        if (delta < TimeSpan.Zero)
        {
            delta = TimeSpan.Zero;
        }

        if (delta.TotalMinutes < 1)
        {
            return "Just now";
        }

        if (delta.TotalHours < 1)
        {
            var minutes = Math.Max(1, (int)Math.Floor(delta.TotalMinutes));
            return $"{minutes} min ago";
        }

        if (delta.TotalDays < 1)
        {
            var hours = Math.Max(1, (int)Math.Floor(delta.TotalHours));
            return hours == 1 ? "1 hr ago" : $"{hours} hrs ago";
        }

        if (delta.TotalDays < 7)
        {
            var days = Math.Max(1, (int)Math.Floor(delta.TotalDays));
            return days == 1 ? "1 day ago" : $"{days} days ago";
        }

        return timestamp.ToLocalTime().ToString("MMM d, yyyy");
    }

    private static string FormatMessageCount(int messageCount)
    {
        return messageCount == 1 ? "1 message" : $"{messageCount} messages";
    }

    private static string GetConversationCountLabel(int count)
    {
        return count == 1 ? "1 conversation" : $"{count} conversations";
    }
}
