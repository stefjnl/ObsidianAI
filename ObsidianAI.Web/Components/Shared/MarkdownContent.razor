@using Markdig
@using ObsidianAI.Web.Services
@inject IJSRuntime JSRuntime

<div class="markdown-content" @ref="markdownElement">
    @((MarkupString)_cachedHtml)
</div>

@code {
    [Parameter]
    public string Content { get; set; } = string.Empty;

    private ElementReference markdownElement;
    private string _cachedHtml = string.Empty;
    private string _lastContent = string.Empty;
    private bool _needsHighlight = false;

    private static readonly MarkdownPipeline Pipeline = new MarkdownPipelineBuilder()
    .UseAdvancedExtensions()
    .UseSoftlineBreakAsHardlineBreak()
    .UsePreciseSourceLocation()
    .Build();

    protected override void OnParametersSet()
    {
        // Only re-convert if content actually changed
        if (_lastContent != Content)
        {
            _cachedHtml = ConvertMarkdown(Content);
            _lastContent = Content;
            _needsHighlight = true; // Flag for syntax highlighting after render
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Apply syntax highlighting only when content changes or first render
        if (firstRender || _needsHighlight)
        {
            _needsHighlight = false;
            try
            {
                await JSRuntime.InvokeVoidAsync("highlightCode", markdownElement);
            }
            catch (JSDisconnectedException)
            {
                // Circuit disconnected, ignore
            }
            catch (TaskCanceledException)
            {
                // Component disposed during async operation, ignore
            }
        }
    }

    private static string ConvertMarkdown(string markdown)
    {
        if (string.IsNullOrWhiteSpace(markdown))
            return string.Empty;

        try
        {
            // Always apply unescape since we can't reliably detect escaped sequences in Razor
            // The TextDecoderService will handle: \n, \r, \t, \", \\, \/, \b, \f, \uXXXX
            var processedMarkdown = TextDecoderService.UnescapeJson(markdown);
            
            System.Diagnostics.Debug.WriteLine($"Markdown conversion - Original length: {markdown.Length}, Processed length: {processedMarkdown.Length}");
            
            // Check if unescaping actually changed anything
            if (!string.Equals(markdown, processedMarkdown, StringComparison.Ordinal))
            {
                System.Diagnostics.Debug.WriteLine($"Unescape applied changes:");
                System.Diagnostics.Debug.WriteLine($"  Original (first 150): {markdown.Substring(0, Math.Min(150, markdown.Length)).Replace("\n", "\\n").Replace("\r", "\\r")}");
                System.Diagnostics.Debug.WriteLine($"  Processed (first 150): {processedMarkdown.Substring(0, Math.Min(150, processedMarkdown.Length)).Replace("\n", "\\n").Replace("\r", "\\r")}");
            }

            var html = Markdown.ToHtml(processedMarkdown, Pipeline);
            return html;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Markdown conversion error: {ex.Message}");
            // Fallback for malformed markdown during streaming
            return $"<pre>{System.Net.WebUtility.HtmlEncode(markdown)}</pre>";
        }
    }
}